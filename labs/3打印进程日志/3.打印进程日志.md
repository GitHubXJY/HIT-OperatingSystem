# 打印进程日志

## 实验内容

本次实验将进程在其整个生存周期（进程从创建到结束）中的运行轨迹记录下来，进程在其生命周期中的运行轨迹实际上表现为进程状态的多次切换，如进程创建以后变成就绪态、进程被调度以后切换到运行态、在运行过程中启动文件读写操作切换到阻塞态、等等。

进程日志记录在`/var/process.log`文件中，其格式为`pid    X   time`。其中`pid`是进程ID；`X`是N（进程新建）、J（进入就绪态）、R（进入运行态）、W（进入阻塞态）和E（进程退出）中的任意一个；`time`表示状态切换时发生的时间，这个时间不是物理时间，而是系统的滴答时间(tick)，即开机以后经过的滴答数。

为了能尽早开始记录，应当在内核启动时就打开日志文件，更准确的说：在进程0开始在用户态执行以后就打开日志文件，因为这个时候已经开启了多进程试图。由系统启动的知识可知，这个时间点在语句`move_to_user_mode()`后面。虽然这是最合适的记录位置，但此时文件系统还没有挂载，所有现在还不能记录。

文件`~/init/main.c`中的`main`函数执行语句：

```C++
void main(void){
    ......
    move_to_user_mode();
    if(!fork()) {init();}
}
```

其中`init()`函数主要以下工作：

```C++
void init(void){
setup((void*)& drive_info);
    (void) open("/dev/tty0",O_RDONLY,0);
    (void) dup(0);
    (void) dup(0);
    ......
}
```

其中第一条语句完成文件系统的加载，第二三四条语句打开标准输入、标准输出和标准错误三个文件，分别对应stdin、stdout和stderr。此时打开日志文件正合适：

```C++
(void) open("/var/process.log",O_CREAT|O_TRUNC|O_WRONLY,0666)
```

将上述打开日志文件的语句和上述`init()`函数中四条语句移动到`move_to_user_mode()`之后，这样一旦0号进程切换到用户态，即多进程视图刚出现就可以开始记录了。

日志文件打开后接下来需要写日志文件，由于日志文件被用来记录进程状态的转移轨迹，而所有的进程状态转移都是在内核中进行的，所以需要在内核状态下进行写文件操作。同时在内核中，write()系统调用的功能无效（系统调用是操作系统提供给上层用户的接口，只能在用户态中使用），因此真正的写文件操作需要依靠内核提供的函数sys_write()来完成，所以可以通过sys_write()来编写一个能工作在内核态的写日志函数fprintk()。

fprintk()函数主要由两部分组成，第一部分是用vsprintf()在logbuf中产生一个格式化字符串，第二部分调用sys_write进行文件输出。fprintk()函数参考printk()函数和sys_write()函数编写。

```C
// fprintk() 代码实现
static char logbuf[1024];
int fprintk(int fd, const char* fmt){
    va_list args;
    int count;
    struct file* file;
    struct m_inode* inode;
    va_start(args,fmt);
    count=vsprintf(logbuf,fmt,args);
    va_end(args);
    if(fd==3){
        count=sys_write(fd,logbuf,count);
    }
    return count;
}
```

有了fprintk()函数后，往日志里输出内容时直接调用这个函数即可，如：`fprintk(3,"%ld\t%c\t%ld\n",current->pid,'R',jiffies);`。其中`jiffies`是在操作系统内核中定义的一个全局变量，该变量记录了从开机到当前时刻时钟中断发生的次数，也被称为滴答数。

本实验项目的最后一个工作就是寻找进程状态切换点，即所有发生进程状态切换的代码点，并在这个位置添加适当的代码，将进程状态变化情况输出到日志文件中。linux0.11支持四种进程状态的转移：就绪到运行、运行到就绪、运行到阻塞、阻塞到就绪、以及新建和退出这两种特殊情况。

# 新建


fork()是新建进程的地方，它是创建进程的系统接口，fork()的功能由内核中的`sys_fork()`函数完成，查看代码后发现真正实现进程创建的函数是`copy_process()`。在copy_process()中会申请一个新的PCB，即`p=(struct task_struct *) get_free_page();`，完成一些设置工作以后会将进程状态设置为就绪态，即`p->state=TASK_RUNNING`，现在这个新的进程已经就绪等待运行了。因此完成进程新建状态的记录就在copy_process()函数中添加新建和就绪两种状态的输出语句：

```C
    ......
    fprintk(3,"%ld\t%c\t%ld\n",p->pid,'N',jiffies);
    p->state=TASK_RUNNING;
    fprintk(3,"%ld\t%c\t%ld\n",p->pid,'J',jiffies);
    ......
```

可以发现，操作系统中有一些语句用于完成状态的设置，如上面的`p->state=TASK_RUNNING;`，这些设置语句正好对应进程状态的切换，所以进程运行日志的输出可以围绕这样的语句来编写。

函数`sleep_on()`中有这样一条语句：`current->state=TASK_UNINTERRUPTIBLE;`，所以输出'W'的语句就紧接着这条语句来编写。

## 实验流程
