## 进程同步--让多个进程的推进合理有序

### 1 进程同步问题与睡眠/唤醒

多个进程在操作系统中并发向前推进，这是操作系统的核心视图，多个进程在并发执行过程中并不一定完全独立，会相互依赖，操作系统需要提供一种机制来帮助进程实现这些依赖关系，即进程同步。

每个进程都有自己要完成的工作，即要执行的程序，因为多个进程之间存在依赖关系，所以进程不能一直执行自己的工作，需要在适当的时候查看其它进程的工作情况，然后根据查看的结果决定下一步要进行的工作。

这就是进程同步的基本结构：一个进程在需要同步的地方停下来等待依赖进程，当依赖进程完成了和同步对应的工作以后，这个进程再继续向前执行。进程同步就是通过对进程的控制来让多个进程步调一致，合理有序的向前推进，完成相互依赖、相互合作。

### 2 从信号到信号量

1. 利用信号解决同步问题

现在已经建立了基于等待和通知的进程同步的轮廓，进程间可以通过信号实现等待和通知：在需要同步的位置，进程将自己阻塞起来等待信号；当该进程所依赖的进程执行到步调一致以后，会向操作系统发出信号；操作系统收到信号以后，将阻塞进程唤醒。但是，单个信号无法应对多变的调度情况，虽然它的语义并没有出错，但是它的语义信息太少，不能充分反映出阻塞在信号上的进程和等待信号的进程的信息。

2. 将信号扩展为信号量

解决的办法是引入新的变量来记录更多的信息，比如要记录等待在信号上的进程个数信息，也可以用这个变量来控制进程的阻塞与唤醒。信号量就是在信号上关联的一个整数，可以根据这个整数来决定进程的阻塞或唤醒。

信号量的定义：1）信号量是一个整形变量，用来记录和进程同步有关的信息；2）能让进程阻塞睡眠在这个信号量上；3）需要同步的进程通过操作（P操作，V操作）信号量实现进程的阻塞和唤醒，即进程的同步。因此信号量就是一个数据对象以及操作这个数据对象的两个操作，其中数据对象是信号量的数值以及相应的阻塞进程队列，在这个数据对象上的两个操作就是对信号量的数值加减，并根据加减后的信号量数值决定进程的睡眠和唤醒。

### 3 临界区--对信号量的保护

信号量的作用是根据信号量数值表达的语义来决定进程的走与停，因此信号量的数值非常重要，只有信号量的数值与信号量对应的语义信息保持一致才能正确的使用信号量来决定进程的走与停。但是信号量要被多个进程共享操作，同时存在于操作系统中的多个并发进程会竞争使用CPU，竞争会导致各种各样的调度结果，有些调度顺序很可能导致共享变量出现语义错误。

因此，多个进程共同修改信号量时需要对信号量进行保护，具体做法是：多个进程可以对某个共同的信号量任意修改，但必须是一个进程修改完成以后才能让其它进程修改。也就是每个进程对信号量的修改要么一点都不做，要么全部做完，中途不能被打断，即对信号量的修改必须是一个原子操作。

因此对信号量的保护就是保证每个进程对信号量的修改操作是原子操作，保护信号量的机制就是在修改信号量的代码的基础上“包裹”其它代码来让信号量的修改操作成为原子操作，为此引入临界区的概念。临界区就是进程中的一段代码，这段代码与其它相关进程中的相关代码对应，一次最多只允许一个进程进入，即互斥进入。被称为临界区的原因是一旦进入了这段代码，操作系统的状态就发生了改变，现在不能在进程间随意切换了。

有了临界区的概念后，信号量保护的实质就是让进程中修改信号量的代码变成临界区代码。具体来说，在修改信号量的代码前加上“进入区”代码，在修改玩信号量以后调用“退出区”代码，从而实现一次只有一个进程对信号量的修改，保证信号量修改的原子性，从而保证信号量的语义始终正确。

进入区和退出区的实现是实现信号量保护的核心内容，有软件实现和硬件实现两种方式。

1. 临界区的软件实现

主要有Peterson算法和Lamport面包店算法。实现临界区的方法要做到以下几点：

* 互斥进入。如果有多个进程要求进入临界区，一次仅允许一个进程进入；在任何时候，一旦已经有进程进入其自身的临界区，则其它所有试图进入相应临界区的进程都必须等待。
* 有空让进。如果没有进程处于临界区内且有进程要求请求进入临界区，则应该能让某个请求进程进入临界区，即不发生资源的死锁情况。
* 有限等待。有限等待意味着一个进程在提出进入临界区请求后，最多需要等待临界区被使用有限次以后，该进程就可以进入临界区。这样，任何一个进程对临界区的等待时间都是有限的，即不出现因等待临界区而造成的饿死情况。

2. 临界区的硬件实现

TestAndSet硬件指令。

### 4 信号量的实现和使用

临界区保护了信号量P、V操作的原子性，从而能够保证信号量数值的语义正确性，接下来根据信号量数值所表达出来的正确语义就可以正确的控制进程的阻塞和唤醒。操作系统给上层用户提供了信号量定义接口以及P、V操作接口后，用户就可以根据需要调用这些接口完成进程同步了。

1. 信号量的使用

根据信号量的定义：1）信号量是一个需要被多个进程共享的整数；2）根据信号量的值让相应的进程睡眠(sleep_on)或唤醒(wake_up)，睡眠和唤醒的操作对象是进程PCB；3）在操作这个整数时要进程临界区保护，可以调用Lamport面包店算法、开关中断等。不管从哪一方面来说，应该将信号量的实现放在操作系统内核，并将信号量的P、V操作实现成系统调用，因为将一个变量放在操作系统内核以后所有进程就可以共享了，并且在操作系统内核中操作PCB等动作简单安全，也能向用户屏蔽细节。

通常，信号量实现为操作系统内核中的一个数据对象，而P、V操作实现为操作系统给上层用户程序提供的两个系统调用。POSIX标准针对信号量定义了四个基本系统调用：

* `sem_t *sem_open(const char* name, int oflag, mode_t mode, unsigned int value);`这个系统调用用来打开或创建一个信号量变量，其中name是信号量的名字；oflag可以选择创建一个新的信号量或打开一个现有的信号量；mode是权限位；value是信号量的初值。
* `int sem_unlink(const char* name);`用来根据名字从操作系统中删除信号量。
* `int sem_wait(sem_t* sem);`对应信号量的P操作。
* `int sem_post(sem_t* sem);`对应信号量的V操作。

2. 信号量的实现

对于有正有负信号量，正值信号量表示现有的资源个数，负值信号量表示有多少个进程等待在该信号量上。其P、V操作对应的系统调用`sys_sem_wait`和`sys_sem_post`的核心是对系统内核中的一个整形变量进行操作，并根据整形变量的数值决定是否要做进程的睡眠或唤醒，并涉及一个阻塞队列的维护操作。

```C++
sys_sem_wait(sem_t* sem){
    cli();  // 进入区代码
    sem->value --;
    if(sem_value < 0){
        current->state = SLEEP; // 将当前进程阻塞
        // 将当前进程追加到sem->queue队列的尾部
        schedule(); // 调用schedule切换到别的进程
    }
    sti();  // 退出区代码
}
```

```C++
sys_sem_post(sem_t* sem){
    cli();
    sem->value ++;
    if(sem->value <= 0){
        // 从sem->queue队列的首部取出一个进程p
        p->state = READY; // 设为就绪态
        // 将p加入到就绪队列中
    }
    sti();
}
```

### 5 死锁现象及死锁处理

1. 死锁现象的出现

由于进程之间的依赖，假设某个进程p0在某个时刻停下来等待另一个进程p1，恰好此时进程p1也在停下来等待进程p0，这种情况下两个进程都无法执行下去，这就是死锁现象。死锁是多个进程在同步时由于互相等待对方向前执行而造成的任一进程都无法向前执行的现象。

2. 死锁出现的条件和死锁预防

死锁发生的四个基本条件（必要条件）是：

* 互斥：资源不能被共享，一个资源每次只能被一个进程使用。
* 不可剥夺：进程以获得的资源在未使用完之前不能被强行剥夺。
* 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
* 循环等待：若干进程之间形成一种环状的循环性资源等待关系。

死锁的预防就是破坏这四个必要条件中的某个条件。

3. 死锁的避免

死锁避免的处理思想是：每次资源申请都要判断是否有出现死锁的危险，如果有就拒绝此次申请。银行家算法就是一个避免死锁的算法。

4. 死锁检测/恢复与死锁忽略

略。
